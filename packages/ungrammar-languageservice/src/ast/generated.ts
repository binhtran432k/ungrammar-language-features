//! Generated by `codegen`, do not edit by hand.

import type { SyntaxNodeRef, TreeCursor } from "@lezer/common";

export interface AstAcceptor {
	syntax: SyntaxNodeRef;
	accept(visitor: AstVisitor): void;
	getChildren(): AstAcceptor[];
}

export abstract class AstVisitor {
	visitGrammar(acceptor: Grammar): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitNode(acceptor: Node): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitRule(acceptor: Rule): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitSequence(acceptor: Sequence): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitAlternative(acceptor: Alternative): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitOptional(acceptor: Optional): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitRepetition(acceptor: Repetition): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitGroup(acceptor: Group): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	visitLabel(acceptor: Label): void {
		for (const c of acceptor.getChildren()) {
			c.accept(this);
		}
	}
	abstract visitIdentifier(acceptor: Identifier): void;
	abstract visitToken(acceptor: Token): void;
}

export class Grammar implements AstAcceptor {
	syntax: SyntaxNodeRef;

	nodes: Node[] = [];

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Node.canCast(cursor)) {
					this.nodes.push(new Node(cursor, unknowns));
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Grammar");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitGrammar(this);
	}

	getChildren(): AstAcceptor[] {
		return [...this.nodes].filter((a): a is AstAcceptor => a !== undefined);
	}
}

export class Node implements AstAcceptor {
	syntax: SyntaxNodeRef;

	name?: Identifier;
	rule?: Rule;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Identifier.canCast(cursor)) {
					this.name = new Identifier(cursor, unknowns);
				} else if (Rule.canCast(cursor)) {
					this.rule = new Rule(cursor, unknowns);
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Node");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitNode(this);
	}

	getChildren(): AstAcceptor[] {
		return [this.name, this.rule].filter(
			(a): a is AstAcceptor => a !== undefined,
		);
	}
}

export class Rule implements AstAcceptor {
	syntax: SyntaxNodeRef;

	identifier?: Identifier;
	token?: Token;
	sequence?: Sequence;
	alternative?: Alternative;
	optional?: Optional;
	repetition?: Repetition;
	group?: Group;
	label?: Label;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Identifier.canCast(cursor)) {
					this.identifier = new Identifier(cursor, unknowns);
				} else if (Token.canCast(cursor)) {
					this.token = new Token(cursor, unknowns);
				} else if (Sequence.canCast(cursor)) {
					this.sequence = new Sequence(cursor, unknowns);
				} else if (Alternative.canCast(cursor)) {
					this.alternative = new Alternative(cursor, unknowns);
				} else if (Optional.canCast(cursor)) {
					this.optional = new Optional(cursor, unknowns);
				} else if (Repetition.canCast(cursor)) {
					this.repetition = new Repetition(cursor, unknowns);
				} else if (Group.canCast(cursor)) {
					this.group = new Group(cursor, unknowns);
				} else if (Label.canCast(cursor)) {
					this.label = new Label(cursor, unknowns);
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Rule");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitRule(this);
	}

	getChildren(): AstAcceptor[] {
		return [
			this.identifier,
			this.token,
			this.sequence,
			this.alternative,
			this.optional,
			this.repetition,
			this.group,
			this.label,
		].filter((a): a is AstAcceptor => a !== undefined);
	}
}

export class Sequence implements AstAcceptor {
	syntax: SyntaxNodeRef;

	rules: Rule[] = [];

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Rule.canCast(cursor)) {
					this.rules.push(new Rule(cursor, unknowns));
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Sequence");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitSequence(this);
	}

	getChildren(): AstAcceptor[] {
		return [...this.rules].filter((a): a is AstAcceptor => a !== undefined);
	}
}

export class Alternative implements AstAcceptor {
	syntax: SyntaxNodeRef;

	rules: Rule[] = [];

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Rule.canCast(cursor)) {
					this.rules.push(new Rule(cursor, unknowns));
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Alternative");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitAlternative(this);
	}

	getChildren(): AstAcceptor[] {
		return [...this.rules].filter((a): a is AstAcceptor => a !== undefined);
	}
}

export class Optional implements AstAcceptor {
	syntax: SyntaxNodeRef;

	rule?: Rule;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Rule.canCast(cursor)) {
					this.rule = new Rule(cursor, unknowns);
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Optional");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitOptional(this);
	}

	getChildren(): AstAcceptor[] {
		return [this.rule].filter((a): a is AstAcceptor => a !== undefined);
	}
}

export class Repetition implements AstAcceptor {
	syntax: SyntaxNodeRef;

	rule?: Rule;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Rule.canCast(cursor)) {
					this.rule = new Rule(cursor, unknowns);
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Repetition");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitRepetition(this);
	}

	getChildren(): AstAcceptor[] {
		return [this.rule].filter((a): a is AstAcceptor => a !== undefined);
	}
}

export class Group implements AstAcceptor {
	syntax: SyntaxNodeRef;

	rule?: Rule;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Rule.canCast(cursor)) {
					this.rule = new Rule(cursor, unknowns);
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Group");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitGroup(this);
	}

	getChildren(): AstAcceptor[] {
		return [this.rule].filter((a): a is AstAcceptor => a !== undefined);
	}
}

export class Label implements AstAcceptor {
	syntax: SyntaxNodeRef;

	label?: Identifier;
	rule?: Rule;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				if (Identifier.canCast(cursor)) {
					this.label = new Identifier(cursor, unknowns);
				} else if (Rule.canCast(cursor)) {
					this.rule = new Rule(cursor, unknowns);
				} else {
					unknowns.push(cursor.node);
				}
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Label");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitLabel(this);
	}

	getChildren(): AstAcceptor[] {
		return [this.label, this.rule].filter(
			(a): a is AstAcceptor => a !== undefined,
		);
	}
}

export class Identifier implements AstAcceptor {
	syntax: SyntaxNodeRef;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				unknowns.push(cursor.node);
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Identifier");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitIdentifier(this);
	}

	getChildren(): AstAcceptor[] {
		return [];
	}
}

export class Token implements AstAcceptor {
	syntax: SyntaxNodeRef;

	constructor(cursor: TreeCursor, unknowns: SyntaxNodeRef[]) {
		this.syntax = cursor.node;
		if (cursor.firstChild()) {
			do {
				unknowns.push(cursor.node);
			} while (cursor.nextSibling());
			cursor.parent();
		}
	}

	static canCast(nodeRef: SyntaxNodeRef) {
		return nodeRef.type.is("Token");
	}

	accept(visitor: AstVisitor) {
		return visitor.visitToken(this);
	}

	getChildren(): AstAcceptor[] {
		return [];
	}
}
